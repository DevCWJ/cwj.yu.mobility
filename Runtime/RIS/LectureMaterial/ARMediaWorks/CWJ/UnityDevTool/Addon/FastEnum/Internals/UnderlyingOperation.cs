#if !UNITY_WEBGL
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
using System;
using System.Runtime.CompilerServices;

using Unity.Collections.LowLevel.Unsafe;

namespace CWJ.EnumHelper.Internal
{
    /// <summary>
    /// Provides underlying type specified operation interface.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal interface IUnderlyingOperation<T>
        where T : struct, Enum
    {
        bool IsContinuous { get; }
        bool IsDefined(ref T value);
        bool TryParse(string text, out T result);
        bool TryGetMember(ref T value, out Member<T> result);
        string ToString(ref T value);
    }



    /// <summary>
    /// Provides sbyte specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class SByteOperation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref sbyte value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref sbyte value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, sbyte>(ref result);
                return sbyte.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, sbyte>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly sbyte _minValue;
            private readonly sbyte _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(sbyte min, sbyte max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, sbyte>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref sbyte value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, sbyte>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref sbyte value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenSByteKeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenSByteKeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, sbyte>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref sbyte value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, sbyte>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref sbyte value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, sbyte>(ref min);
            var maxValue = UnsafeUtility.As<T, sbyte>(ref max);
            var memberByValue
                = members.ToFrozenSByteKeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, sbyte>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref sbyte value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides byte specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class ByteOperation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref byte value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref byte value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, byte>(ref result);
                return byte.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, byte>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly byte _minValue;
            private readonly byte _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(byte min, byte max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, byte>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref byte value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, byte>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref byte value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenByteKeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenByteKeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, byte>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref byte value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, byte>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref byte value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, byte>(ref min);
            var maxValue = UnsafeUtility.As<T, byte>(ref max);
            var memberByValue
                = members.ToFrozenByteKeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, byte>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref byte value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides short specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class Int16Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref short value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref short value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, short>(ref result);
                return short.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, short>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly short _minValue;
            private readonly short _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(short min, short max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, short>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref short value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, short>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref short value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenInt16KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenInt16KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, short>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref short value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, short>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref short value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, short>(ref min);
            var maxValue = UnsafeUtility.As<T, short>(ref max);
            var memberByValue
                = members.ToFrozenInt16KeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, short>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref short value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides ushort specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class UInt16Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref ushort value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref ushort value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, ushort>(ref result);
                return ushort.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, ushort>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly ushort _minValue;
            private readonly ushort _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(ushort min, ushort max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref ushort val = ref UnsafeUtility.As<T, ushort>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref ushort value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref ushort val = ref UnsafeUtility.As<T, ushort>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref ushort value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenUInt16KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenUInt16KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, ushort>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref ushort value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, ushort>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref ushort value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, ushort>(ref min);
            var maxValue = UnsafeUtility.As<T, ushort>(ref max);
            var memberByValue
                = members.ToFrozenUInt16KeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, ushort>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref ushort value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides int specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class Int32Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref int value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref int value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref int x = ref UnsafeUtility.As<T, int>(ref result);
                return int.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref int val = ref UnsafeUtility.As<T, int>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly int _minValue;
            private readonly int _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(int min, int max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, int>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref int value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, int>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref int value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenInt32KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenInt32KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, int>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref int value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, int>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref int value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, int>(ref min);
            var maxValue = UnsafeUtility.As<T, int>(ref max);
            var memberByValue
                = members.ToFrozenInt32KeyDictionary(static x =>
                {
                    T value = x.Value;
                    return UnsafeUtility.As<T, int>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref int value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides uint specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class UInt32Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref uint value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref uint value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, uint>(ref result);
                return uint.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, uint>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly uint _minValue;
            private readonly uint _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(uint min, uint max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, uint>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref uint value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, uint>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref uint value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenUInt32KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenUInt32KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, uint>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref uint value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, uint>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref uint value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, uint>(ref min);
            var maxValue = UnsafeUtility.As<T, uint>(ref max);
            var memberByValue
                = members.ToFrozenUInt32KeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, uint>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref uint value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides long specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class Int64Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref long value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref long value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, long>(ref result);
                return long.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, long>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly long _minValue;
            private readonly long _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(long min, long max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, long>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref long value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, long>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref long value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenInt64KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenInt64KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, long>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref long value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, long>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref long value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, long>(ref min);
            var maxValue = UnsafeUtility.As<T, long>(ref max);
            var memberByValue
                = members.ToFrozenInt64KeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, long>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref long value)
            => _operation.IsDefined(ref value);
        #endregion
    }



    /// <summary>
    /// Provides ulong specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal static class UInt64Operation<T>
        where T : struct, Enum
    {
        #region Inner Classes
        private abstract class UnderlyingOperation : IUnderlyingOperation<T>
        {
            public abstract bool IsContinuous { get; }
            public abstract bool IsDefined(ref T value);
            public abstract bool IsDefined(ref ulong value);
            public abstract bool TryGetMember(ref T value, out Member<T> result);
            public abstract bool TryGetMember(ref ulong value, out Member<T> result);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool TryParse(string text, out T result)
            {
                result = default;
                ref var x = ref UnsafeUtility.As<T, ulong>(ref result);
                return ulong.TryParse(text, out x);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public string ToString(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, ulong>(ref value);
                return this.TryGetMember(ref val, out var member)
                    ? member.Name
                    : val.ToString();
            }
        }


        private sealed class Continuous : UnderlyingOperation
        {
            private readonly ulong _minValue;
            private readonly ulong _maxValue;
            private readonly Member<T>[] _members;

            public Continuous(ulong min, ulong max, Member<T>[] members)
            {
                this._minValue = min;
                this._maxValue = max;
                this._members = members;
            }

            public override bool IsContinuous
                => true;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, ulong>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref ulong value)
                => (this._minValue <= value) && (value <= this._maxValue);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, ulong>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref ulong value, out Member<T> result)
            {
                var index = value - this._minValue;
                if ((uint)index < (uint)this._members.Length)
                {
                    result = this._members[index];
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
        }


        private sealed class Discontinuous : UnderlyingOperation
        {
            private readonly FrozenUInt64KeyDictionary<Member<T>> _memberByValue;

            public Discontinuous(FrozenUInt64KeyDictionary<Member<T>> memberByValue)
                => this._memberByValue = memberByValue;

            public override bool IsContinuous
                => false;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref T value)
            {
                ref var val = ref UnsafeUtility.As<T, ulong>(ref value);
                return this.IsDefined(ref val);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool IsDefined(ref ulong value)
                => this._memberByValue.ContainsKey(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref T value, out Member<T> result)
            {
                ref var val = ref UnsafeUtility.As<T, ulong>(ref value);
                return this.TryGetMember(ref val, out result);
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryGetMember(ref ulong value, out Member<T> result)
                => this._memberByValue.TryGetValue(value, out result);
        }
        #endregion


        #region Fields
        private static UnderlyingOperation _operation;
        #endregion


        #region Create
        public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
        {
            var minValue = UnsafeUtility.As<T, ulong>(ref min);
            var maxValue = UnsafeUtility.As<T, ulong>(ref max);
            var memberByValue
                = members.ToFrozenUInt64KeyDictionary(static x =>
                {
                    var value = x.Value;
                    return UnsafeUtility.As<T, ulong>(ref value);
                });
            if (memberByValue.Count > 0)
            {
                var length = maxValue - minValue;
                var count = memberByValue.Count - 1;
                if (length == (ulong)count)
                {
                    _operation = new Continuous(minValue, maxValue, members);
                    return _operation;
                }
            }
            _operation = new Discontinuous(memberByValue);
            return _operation;
        }
        #endregion


        #region IsDefined
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(ref ulong value)
            => _operation.IsDefined(ref value);
        #endregion
    }
} 
#endif